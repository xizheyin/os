# 😇 一个小实验

先在实验根目录里输入`make`，然后输入（下面这行意思是不弹窗）：

```
$ make qemu-nox-gdb
```

或者（下面这行意思是有弹窗）：

```
$ make qemu-gdb
```

这时就会开启`qemu`里的`gdb server`。

然后在实验根目录再打开一个终端，输入`make gdb`，观察一下。

{% hint style="info" %}
exercise1：根据你看到的，回答下面问题

我们从看见的那条指令可以推断出几点：

* 电脑开机第一条指令的地址是什么，这位于什么地方？
* 电脑启动时`CS`寄存器和`IP`寄存器的值是什么？
* 第一条指令是什么？为什么这样设计？（后面有解释，用自己话简述）
{% endhint %}

### QEMU为什么会这样启动呢?

`Intel`就是这样设计`8088`处理器的（不同CPU架构下，BIOS可能不一样，这里只是举了x86架构的例子）。

因为电脑的`BIOS`是“天生的”物理地址范围`0x000f0000-0x000fffff`，这种设计可以确保机器的`BIOS`总是在开机之后先获得机器控制权（位置固定）。`QEMU`模拟器自带自己的`BIOS`，它将`BIOS`放置在处理器模拟物理地址空间的这个位置。处理器复位时，（模拟）处理器进入实模式，并将`CS`设置为`0xf000`, `IP`设置为`0xfff0`。

那么分段地址`0xf000:fff0`如何变成物理地址？

为了回答这个问题，我们需要了解一些关于实际模式寻址的知识。在实模式下(即`PC`刚启动的模式)，地址转换的工作公式为:`物理地址= 16 *段+偏移量`。

因此，当计算机将`CS`设置为`0xf000`, `IP`设置为`0xfff0`时，所引用的物理地址为:

```c
  16 * 0xf000 + 0xfff0   # in hex multiplication by 16 is
   = 0xf0000 + 0xfff0    # easy--just append a 0.
   = 0xffff0 
```

`0xffff0`是`BIOS`结束前16个字节(`0x100000`)。在第一条指令的后面只有16个字节，啥也干不了。所以，......

{% hint style="info" %}
exercise2：请翻阅根目录下的`makefile`文件，简述`make qemu-nox-gdb`和`make gdb`是怎么运行的（`.gdbinit`是`gdb`初始化文件，了解即可）
{% endhint %}
